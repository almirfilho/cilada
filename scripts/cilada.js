// Generated by CoffeeScript 1.3.3
(function() {
  var $canvas, Ball, CiladaObject, Wall, b2Body, b2BodyDef, b2CircleShape, b2DebugDraw, b2Fixture, b2FixtureDef, b2PolygonShape, b2Vec2, b2World, ball, bodyDef, config, ctx, fixDef, init, orientation, update, walls, world,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  b2Vec2 = Box2D.Common.Math.b2Vec2;

  b2BodyDef = Box2D.Dynamics.b2BodyDef;

  b2Body = Box2D.Dynamics.b2Body;

  b2FixtureDef = Box2D.Dynamics.b2FixtureDef;

  b2Fixture = Box2D.Dynamics.b2Fixture;

  b2World = Box2D.Dynamics.b2World;

  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  config = {
    debug: false,
    width: 700,
    height: 432,
    scale: 30,
    ball: {
      iniX: 30,
      iniY: 30,
      radius: 15
    },
    walls: {
      qnt: 6,
      width: 15
    }
  };

  CiladaObject = (function() {

    function CiladaObject() {}

    return CiladaObject;

  })();

  Ball = (function(_super) {

    __extends(Ball, _super);

    function Ball(x, y, radius) {
      this.radius = radius;
      this.position = new b2Vec2(x / config.scale, y / config.scale);
      this.impulse = new b2Vec2(0, 0);
      fixDef.density = 0.5;
      fixDef.friction = 1;
      fixDef.restitution = 0;
      fixDef.shape = new b2CircleShape(this.radius / config.scale);
      bodyDef.type = b2Body.b2_dynamicBody;
      bodyDef.position.x = this.position.x;
      bodyDef.position.y = this.position.y;
      bodyDef.linearDamping = 1;
      bodyDef.userData = {
        name: 'bola!'
      };
      this.b2Obj = world.CreateBody(bodyDef);
      this.b2Obj.CreateFixture(fixDef);
    }

    Ball.prototype.move = function() {
      this.b2Obj.ApplyImpulse(this.impulse, this.b2Obj.GetWorldCenter());
      return this.position = this.b2Obj.GetPosition();
    };

    Ball.prototype.draw = function() {
      ctx.fillStyle = 'red';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.arc(this.position.x * config.scale, this.position.y * config.scale, ball.radius, 0, Math.PI * 2, true);
      ctx.closePath();
      return ctx.fill();
    };

    return Ball;

  })(CiladaObject);

  Wall = (function(_super) {

    __extends(Wall, _super);

    function Wall(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.4;
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsBox(this.width / config.scale / 2, this.height / config.scale / 2);
      bodyDef.type = b2Body.b2_staticBody;
      bodyDef.position.x = (this.x / config.scale) + this.width / config.scale / 2;
      bodyDef.position.y = (this.y / config.scale) + this.height / config.scale / 2;
      this.b2Obj = world.CreateBody(bodyDef);
      this.b2Obj.CreateFixture(fixDef);
    }

    Wall.prototype.draw = function() {
      ctx.save();
      ctx.fillStyle = '#cccccc';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      return ctx.restore();
    };

    return Wall;

  })(CiladaObject);

  ball = null;

  walls = [];

  $canvas = $('canvas');

  ctx = $canvas[0].getContext('2d');

  world = null;

  fixDef = null;

  bodyDef = null;

  $canvas.attr({
    'width': config.width,
    'height': config.height
  });

  $canvas.css({
    'top': "-webkit-calc(50% - " + (config.height / 2) + "px)",
    'left': "-webkit-calc(50% - " + (config.width / 2) + "px)"
  });

  init = function() {
    var debugDraw, h, i, w, x, y, _i, _ref;
    world = new b2World(new b2Vec2(0, 0), true);
    fixDef = new b2FixtureDef;
    bodyDef = new b2BodyDef;
    walls.push(new Wall(0, 0, config.width, config.walls.width));
    walls.push(new Wall(0, config.height - config.walls.width, config.width, config.walls.width));
    walls.push(new Wall(0, 0, config.walls.width, config.height));
    walls.push(new Wall(config.width - config.walls.width, 0, config.width, config.height));
    w = config.walls.width;
    h = config.height * 0.8;
    for (i = _i = 1, _ref = config.walls.qnt; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      x = i * ((config.width - config.walls.width) / (config.walls.qnt + 1));
      y = i % 2 === 0 ? config.height * 0.2 : 0;
      walls.push(new Wall(x, y, w, h));
    }
    ball = new Ball(config.ball.iniX, config.ball.iniY, config.ball.radius);
    if (config.debug) {
      debugDraw = new b2DebugDraw();
      debugDraw.SetSprite(ctx);
      debugDraw.SetDrawScale(config.scale);
      debugDraw.SetFillAlpha(0.3);
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
      return world.SetDebugDraw(debugDraw);
    }
  };

  update = function() {
    var wall, _i, _len;
    world.Step(1 / 60, 10, 10);
    ball.move();
    if (config.debug) {
      world.DrawDebugData();
    } else {
      ctx.clearRect(0, 0, config.width, config.height);
      ball.draw();
      for (_i = 0, _len = walls.length; _i < _len; _i++) {
        wall = walls[_i];
        wall.draw();
      }
    }
    world.ClearForces();
    return requestAnimFrame(update);
  };

  init();

  requestAnimFrame(update);

  orientation = false;

  if (window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', function(orientData) {
      ball.impulse.x = orientData.gamma / config.scale / 2;
      ball.impulse.y = orientData.beta / config.scale / 2;
      return orientation = true;
    });
  }

  if (window.DeviceMotionEvent && !orientation) {
    window.addEventListener('devicemotion', function(event) {
      ball.impulse.x = event.accelerationIncludingGravity.x / config.scale * (-3);
      ball.impulse.y = event.accelerationIncludingGravity.y / config.scale * 3;
      return orientation = true;
    });
  }

}).call(this);
